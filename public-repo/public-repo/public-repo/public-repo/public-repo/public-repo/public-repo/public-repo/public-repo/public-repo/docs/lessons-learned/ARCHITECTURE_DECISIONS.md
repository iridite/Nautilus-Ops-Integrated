# 架构决策记录

本文档记录项目中的重要架构决策和经验教训。

## 1. 模块化策略架构 (2026-02-20)

**问题**: 策略代码单体化，重复率高（每个策略约 1080 行）
- 新策略开发需要 3-5 天
- 90% 代码重复
- 难以维护和测试

**解决方案**: 提取可复用组件到 `strategy/common/`
- 创建 7 个可复用组件（指标、信号、universe）
- 策略代码减少 40% (1080 → 650 行)
- 代码复用率提升 700% (10% → 80%)

**关键经验**:
1. **组件设计**: 单一职责，清晰接口
2. **测试优先**: 提取组件前先编写测试
3. **逻辑验证**: 验证重构后的代码产生相同结果
4. **文档完善**: 全面的文档加速采用
5. **渐进迁移**: 过渡期间保留原始版本

## 2. 性能分析与性能分析工具 (2026-02-20)

**问题**: 需要工具来评估策略性能和识别回测瓶颈

**解决方案**: 构建全面的性能分析和性能分析工具
- 创建策略性能分析工具（约 1,790 行）
- 创建回测性能分析工具（约 1,450 行）
- 实现 13 个性能指标（Sharpe、Sortino、Calmar 等）
- 集成 cProfile 进行瓶颈识别

**关键发现**:
- ✅ 高级引擎比低级引擎快 32%（272.45s vs 360.92s）
- ✅ 数据加载是主要瓶颈（10x 差异：66.75s vs 6.5s）
- ✅ Parquet 缓存提供 10x 数据加载速度提升

**意外发现**:
- 最初假设低级引擎会更快（代码更简单）
- 实际测试显示高级引擎快 32%
- 原因: Parquet 缓存 vs 重复 CSV 读取
- 教训: 始终测量，不要假设

## 3. 配置系统简化 (2026-01-31)

**问题**: 配置系统过于复杂（4 层架构）

**解决方案**: 简化为 3 层架构
- YAML → Pydantic 验证 → Adapter → 应用
- 删除 2 个文件，移除 429 行代码
- 统一使用 Pydantic 进行验证

**关键经验**:
1. **简单即美**: 更少的层次 = 更容易理解
2. **统一验证**: Pydantic 提供类型安全和验证
3. **清晰接口**: `get_adapter()` 提供统一访问点
